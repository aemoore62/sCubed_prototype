/**
 * @license
 * 
 * Copyright 2023 Abigail Elizabeth (ORCID ID 0000-0001-8627-777X)
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
* @fileoverview Utilities for establishing conditional formatting.
* @description WARNING! The order in which conditional formatting
* is set is significant.
* @author Abigail Elizabeth 
*/

/**  
 * Applies conditional formatting to the conceptDefinition form
 * @param {sheet} sheet - The sheet that contains the form.
 * @param {array} scubedConfigPackage - The packages (not provenance)
 * that are selected during configuration and set as properties of the sheet.
 * @todo Re-implement designation (attribute) to indicate if the catalog number
 * for an external material is generated by the manufacturer. This is the
 * "special case" that's commented out.
 * @todo Replace hard-coded form name and packages with global vars.
 */

const applyConditionalFormattingConceptDefinitionForm = (sheet, scubedConfigPackage) => {
  const formName = 'conceptDefinition';
  let columnNames = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  var checksEntry = true;
  var isEqual = true;

  if (scubedConfigPackage.indexOf('core') > -1) {
    var entityTypes = globalCubeCoreEntities.conceptDefinition;

    applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, ['core'], '', columnNames);

  }

  if (scubedConfigPackage.indexOf('organism items') > -1) {
    var entityTypes = globalCubeOrganismEntities.conceptDefinition;

    applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, ['organism items'], '', columnNames);

  }

  //applyConditionalFormattingToForm(sheet,formName,allEntityTypes,checksEntry,isEqual,scubedConfigPackage);  

  /*
 
   // special case
  
   var isEqual = false;
   var checksEntry = true;
   entityTypes = ['catalog number external material']
   applyConditionalFormattingToForm(sheet,formName,entityTypes,checksEntry,isEqual);
   
   */

}

//Register externally sourced material
/**  
 * Applies conditional formatting to the materialDefinition form
 * @param {sheet} sheet - The sheet that contains the form.
 * @param {array} scubedConfigPackage - The packages (not provenance)
 * that are selected during configuration and set as a property of the sheet.
 * @param {array} sCubedProvenancePackage - The provenance that is selected
 * during configuration and set as a property of the sheet.
 * @todo Replace hard-coded form name, packages, and provenance type with global vars.
 */

const applyConditionalFormattingMaterialDefinitionForm = (sheet, scubedConfigPackage, sCubedProvenancePackage) => {
  const formName = 'materialDefinition';
  var checksEntry = true;
  var isEqual = true;
  let columnNames = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  var sCubedProvenancePackage = getValueFromSpreadsheetProperty('scubed_provenance_type');

  if (sCubedProvenancePackage.indexOf('activity') > -1) {
    var entityTypes = globalCubeCoreEntities.materialDefinition.activityLevel;
    applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, scubedConfigPackage, ['core'], columnNames);

  }

  if (sCubedProvenancePackage.indexOf('summary') > -1) {
    var entityTypes = globalCubeCoreEntities.materialDefinition.summaryLevel;
    applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, scubedConfigPackage, ['summary'], columnNames);

  }

  /*
 
   // special case
  
   var isEqual = false;
   var checksEntry = true;
   entityTypes = ['catalog number external material']
   applyConditionalFormattingToForm(sheet,formName,entityTypes,checksEntry,isEqual);
   
   */

}

function tester() {
  console.log(globalCubeCoreEntities.materialDefinition.activityLevel)
}

/**  
 * Applies conditional formatting to the processDefinition form
 * @param {sheet} sheet - The sheet that contains the form.
 * @param {array} scubedConfigPackage - The packages (not provenance)
 * that are selected during configuration and set as a property of the sheet.
 * @todo Re-implement designation (attribute) to indicate if the catalog number
 * for an external material is generated by the manufacturer. This is the
 * "special case" that's commented out.
 * @todo Replace hard-coded form name and provenance type with global vars.
 */

const applyConditionalFormattingProcessDefinitionForm = (sheet, scubedConfigPackage) => {
  const formName = 'processDefinition';
  let columnNames = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];

  var checksEntry = true;
  var isEqual = true;

  if (scubedConfigPackage.indexOf('CIDC') > -1) {
    var entityTypes = globalCubeInVitroCellCulture.processDefinition;
    applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, ['core', 'CIDC'], '', columnNames);

  } else {
    var entityTypes = //['process_type establishing culture growth environment', 'process_type seed', 'process_type fermentation', 'process_type weight measurement', 'process_type resuspension', 'process_type aliquoting', 'process_type snap freeze', 'process_type storage', 'process_type wash', 'process_type specimen pooling', 'process_type counting', 'process_type Freeze-Drying', 'process_type substance combination', 'process_type open', 'process_type volume measurement', 'process_type transfer', 'process_type spot bleach', 'process_type microbial culture procedure', 'process_type autoclave', 'process_type centrifugation', 'process_type bead-based homogenization', 'process_type solvent preparation', 'process_type solvent extraction', 'process_type harvest culture growth environment', 'process_type optical density measurement', 'process_type passage'];
      applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, ['core'], '', columnNames);

  }

  /*
 
   // special case
  
   var isEqual = false;
   var checksEntry = true;
   entityTypes = ['catalog number external material']
   applyConditionalFormattingToForm(sheet,formName,entityTypes,checksEntry,isEqual);
   
   */

}

/**  
 * Applies conditional formatting to the materialDefinition form
 * @param {sheet} sheet - The sheet that contains the form.
 * @param {array} scubedConfigPackage - The packages (not provenance)
 * that are selected during configuration and set as a property of the sheet.
 * @todo Re-implement designation (attribute) to indicate if the catalog number
 * for an external material is generated by the manufacturer. This is the
 * "special case" that's commented out.
 * @todo Replace hard-coded form name, packages, and provenance type with global vars.
 */

const applyConditionalFormattingWorkflowManagementForm = (sheet, scubedConfigPackage) => {
  const formName = 'workflowManagement';
  let columnNames = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  var entityTypes = globalCubeInVitroCellCulture.workflowManagement;
  //,'summary of provenance'
  var checksEntry = true;
  var isEqual = true;

  applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, scubedConfigPackage, ['core'], columnNames);

  var sCubedProvenancePackage = getValueFromSpreadsheetProperty('scubed_provenance_type');

  if (sCubedProvenancePackage.indexOf('summary') > -1) {

    var entityTypes = ['workflow_entity_type summary of provenance'];

    applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, scubedConfigPackage, ['summary'], columnNames);

  }

  /*
 
   // special case
  
   var isEqual = false;
   var checksEntry = true;
   entityTypes = ['catalog number external material']
   applyConditionalFormattingToForm(sheet,formName,entityTypes,checksEntry,isEqual);
   
   */

}

/**  
 * Applies conditional formatting to the materialDefinition form
 * @param {Object} sheet - The sheet that contains the form.
 * @param {array} existingPackages - The packages (not provenance)
 * that are selected during configuration and set as a property of the sheet.
 * @param {array} provenanceType - The provenance that is selected
 * during configuration and set as a property of the sheet.
 * @todo Re-implement designation (attribute) to indicate if the catalog number
 * for an external material is generated by the manufacturer. This is the
 * "special case" that's commented out.
 * @todo Replace hard-coded form name, packages, and provenance type with global vars.
 */

const applyConditionalFormattingProcessExecutionForm = (sheet, existingPackages, provenanceType) => {
  const formName = 'processExecution';
  let columnNames = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];

  var checksEntry = true;
  var isEqual = true;

  if (existingPackages.indexOf('CIDC') > -1 && provenanceType === 'activity') {
    var entityTypes = globalCubeInVitroCellCulture.processExecution;

    applyConditionalFormattingToForm(sheet, formName, entityTypes, checksEntry, isEqual, existingPackages, ['activity'], columnNames);

  }

  /*
 
   // special case
  
   var isEqual = false;
   var checksEntry = true;
   entityTypes = ['catalog number external material']
   applyConditionalFormattingToForm(sheet,formName,entityTypes,checksEntry,isEqual);
   
   */

}

/**  
 * Apply conditional formatting to any form
 * @param {sheet} sheet - The sheet that contains the form.
 * @param {string} formName - The name of the form.
 * @param {[string]} entityTypes - The types of entities to iterate over & apply formatting.
 * @param {string} checksEntry - Does formatting formula check user entry to apply format?
 * @param {boolean} isEqual - The formatting formula checks that a value IS EQUAL to another value. 
 * @param {array} scubedConfigPackage - The packages (not provenance)
 * that are selected during configuration and set as a property of the sheet.
 * @param {array} provenanceType - The provenance that is selected
 * during configuration and set as a property of the sheet.
 * @param {array} columnNames - The names of the column in the sheet that will be formatted.
 * NOTE: In some forms, certain attributes are always required (checksEntry = false),
 * e.g. person in processExecution.
 * @todo Replace hard-coded form name, packages, provenance type, and column names with global vars.
 * @todo Update the var name searchSheet to reflect that that var now actually represents sheet values.
 */

const applyConditionalFormattingToForm = (sheet, formName, entityTypes, checksEntry, isEqual, scubedConfigPackage, sCubedProvenancePackage, columnNames) => {
  let isMiniTableHeaderColumnNumber = columnNameToColumnNumber(sheet, ['helper_is_mini_table_header']);
  let rangeIsMiniTableHeader = sheet.getRange(1, isMiniTableHeaderColumnNumber, 50, 1).getA1Notation();
  var sheetRules = sheet.getConditionalFormatRules();
  let totalRows = sheet.getMaxRows();
  let totalColumns = sheet.getLastColumn();
  let rangeList = createRangeList(sheet, totalColumns, totalRows);
  let rangeListA1 = rangeList.map(range => range.getA1Notation());
  let searchSheet = getCurrentSheetValues(formName); // these are actually the sheet's values

  for (var entityTypeIndex = 0; entityTypeIndex < entityTypes.length; entityTypeIndex++) {
    var isDependent = false;

    try {
      if (formName == 'materialDefinition' && sCubedProvenancePackage.indexOf('summary') > -1) { //sCubedProvenancePackage !== null && scubedConfigPackage !== undefined

        var entityObject = getCurrentEntityObjectColumnVisibilityMaterialDefinitionProvenanceSummary(entityTypes[entityTypeIndex]);
      } else if (formName == 'conceptDefinition' && scubedConfigPackage.indexOf('core') > -1) {
        var entityObject = getCurrentEntityObjectColumnVisibilityConceptDefinitionCore(entityTypes[entityTypeIndex]);
      } else if (formName == 'conceptDefinition' && scubedConfigPackage.indexOf('organism items') > -1) {
        var entityObject = getEntityObjectColumnVisibilityConceptDefinitionOrganismPackage(entityTypes[entityTypeIndex]);
      } else if (formName == 'materialDefinition' && scubedConfigPackage.indexOf('core') > -1) {
        var entityObject = getCurrentEntityObjectColumnVisibilityMaterialDefinitionCore(entityTypes[entityTypeIndex]);
      } else if (formName == 'workflowManagement' && scubedConfigPackage.indexOf('core') > -1) {
        var entityObject = getEntityObjectColumnVisibilityWorkflowManagement(entityTypes[entityTypeIndex]);
      } else if (formName === 'processDefinition' && scubedConfigPackage.indexOf('core') > -1) {
        var entityObject = getCurrentEntityObjectColumnVisibilityProcessDefinitionCore(entityTypes[entityTypeIndex]);
        if (entityObject === 'none' && scubedConfigPackage.indexOf('CIDC') > -1) {

          var entityObject = getCurrentEntityObjectColumnVisibilityProcessDefinitionCore(entityTypes[entityTypeIndex]);
        }
      } else if (formName == 'materialDefinition') {
        var entityObject = getEntityObjectColumnVisibilityMaterialDefinitionCore(entityTypes[entityTypeIndex]);
      } else if (formName === 'processExecution') {
        var entityObject = getCurrentEntityObjectColumnVisibilityProcessExecution(entityTypes[entityTypeIndex]);
      }

      if (formName == 'workflowManagement' && sCubedProvenancePackage === 'summary') {
        var entityObject = getEntityObjectColumnVisibilityWorkflowManagement(entityTypes[entityTypeIndex]);

      }

    } catch (err) {
      // handle provenance columns
      /*
      if (formName == 'materialDefinition' && sCubedProvenancePackage !== null && scubedConfigPackage !== undefined) {
        var entityObject = getCurrentEntityObjectColumnVisibilityMaterialDefinitionProvenanceSummary
      }
      */


    }

    let enteredInColumName = entityObject.entityEnteredInColumnName;

    let currentEntityColumnNumber = searchSheet[0].indexOf(enteredInColumName);
    let entityName = entityObject.entityName;
    let attributesObject = getObjectsFromObjectFunctionsByKey(entityObject, 'attributes');

    var firstKey = true;

    for (var key of Object.keys(attributesObject)) {
      let attributeCharacteristcs = attributesObject[key];

      if (checksEntry) {
        var rangeEntityDeterminer = rangeListA1[currentEntityColumnNumber];

      }

      var isRequired = attributeCharacteristcs.isRequired;
      var supportsMultipleValues = attributeCharacteristcs.supportsMultipleValues;
      var currentAttributeColumnNumber = columnNames.indexOf(key) + 1;
      var rangeToFormat = rangeList[currentAttributeColumnNumber - 1]; // formulaRange

      if (attributeCharacteristcs.dependsOnColumnName != null) {
        var dependsOnColumnName = attributeCharacteristcs.dependsOnColumnName;
        var dependsOnColumnNumber = columnNames.indexOf(dependsOnColumnName) + 1;
        var rangeToCheckIfBlank = rangeListA1[currentAttributeColumnNumber];
        isDependent = true;
        dependsOnColumnNumber = columnNames.indexOf(dependsOnColumnName) + 1;
        var rangeDependentToCheckIfBlank = rangeListA1[dependsOnColumnNumber];

      } else if (currentAttributeColumnNumber > 0) {
        //currentAttributeColumnNumber > 0 to deal with cond formatting processDefinition when CIDC pkg is not selected
        //b/c additional columns aren't there (result of selecting CIDC pkg) we need to skip the expected columns
        isDependent = false;

        var rangeToCheckIfBlank = rangeListA1[currentAttributeColumnNumber - 1];

      }

      if (isDependent) {
        var sheetRules = applyConditionalFormattingPerAttribute(sheet, rangeToCheckIfBlank,
          rangeEntityDeterminer, rangeIsMiniTableHeader, isRequired, supportsMultipleValues, checksEntry, entityName, rangeToFormat, isDependent, isEqual, rangeDependentToCheckIfBlank, sheetRules)

      } else if (currentAttributeColumnNumber > 0) {
        //currentAttributeColumnNumber > 0 to deal with cond formatting processDefinition when CIDC pkg is not selected
        //b/c additional columns aren't there (result of selecting CIDC pkg) we need to skip the expected columns
        var sheetRules = applyConditionalFormattingPerAttribute(sheet, rangeToCheckIfBlank,
          rangeEntityDeterminer, rangeIsMiniTableHeader, isRequired, supportsMultipleValues, checksEntry, entityName, rangeToFormat, isDependent, isEqual, undefined, sheetRules)

      }

    }
  }

  sheet.setConditionalFormatRules(sheetRules);
}

/**  
 * Apply conditional formatting per attribute
 * @param {sheet} sheet - The sheet to be formatted.
 * @param {range} rangeToCheckIfBlank - The range that the formula should check is blank.
 * @param {range} rangeEntityDeterminer - The range that the formula should check for user entry to 
 * dynamically render formatting.
 * @param {range} rangeIsMiniTableHeader - The range that the formula should check to distinguish
 * header vs. non-head rows for mini tables.
 * @param {string} checksEntry - Does formatting formula check user entry to apply format?
 * @param {string} entityName - The entity that the formula should look for in user entries to dynamically render formatting.
 * @param {range} rangeToFormat - The range to be formatted.
 * @param {boolean} isDependent - The formatting of the ranging is dependent upon a value in another range.
 * @param {boolean} isEqual - The formatting formula checks that a value IS EQUAL to another value. 
 * @param {range} rangeDependentToCheckIfBlank - The Range that determines if a value is required in the range that is being formatted.
 * @param {Array.<*[]>} sheetRules - The conditional formatting rules in the sheet to be formatted. 
 * @return {Array.<*[]>} sheetRules - The updated conditional formatting rules in the sheet to be formatted. 
 */

const applyConditionalFormattingPerAttribute = (sheet, rangeToCheckIfBlank,
  rangeEntityDeterminer, rangeIsMiniTableHeader, isRequired, supportsMultipleValues, checksEntry, entityName, rangeToFormat, isDependent, isEqual, rangeDependentToCheckIfBlank, sheetRules) => {

  var sheetRules = setConditionalFormattingForPrimaryRow(sheet, rangeToCheckIfBlank,
    rangeEntityDeterminer, rangeIsMiniTableHeader, isRequired, checksEntry, entityName, rangeToFormat, isEqual, isDependent, rangeDependentToCheckIfBlank, sheetRules);

  if (supportsMultipleValues) {
    var sheetRules = setConditionalFormattingSecondaryRow(sheet,
      rangeToCheckIfBlank, rangeEntityDeterminer, rangeIsMiniTableHeader, isRequired, checksEntry, entityName, rangeToFormat, sheetRules);

  }

  return sheetRules;

}

/**  
 * Apply conditional formatting for rows unassociated with min tables and rows that head mini tables
 * @param {sheet} sheet - The sheet to be formatted.
 * @param {range} rangeToCheckIfBlank - The range that the formula should check is blank.
 * @param {range} rangeEntityDeterminer - The range that the formula should check for user entry to 
 * dynamically render formatting.
 * @param {range} rangeIsMiniTableHeader - The range that the formula should check to distinguish
 * header vs. non-head rows for mini tables.
 * @param {boolean} isRequired - Specifies if the attribute is required.
 * @param {string} checksEntry - Does formatting formula check user entry to apply format?
 * @param {string} entityName - The entity that the formula should look for in user entries to dynamically render formatting.
 * @param {range} rangeToFormat - The range to be formatted.
 * @param {boolean} isDependent - The formatting of the ranging is dependent upon a value in another range.
 * @param {boolean} isEqual - The formatting formula checks that a value IS EQUAL to another value. 
 * @param {range} rangeDependentToCheckIfBlank - The Range that determines if a value is required in the range that is being formatted.
 * @param {Array.<*[]>} sheetRules - The conditional formatting rules in the sheet to be formatted.  
 * @return {Array.<*[]>} sheetRules - The updated conditional formatting rules in the sheet to be formatted.
 */

const setConditionalFormattingForPrimaryRow = (sheet, rangeToCheckIfBlank,
  rangeEntityDeterminer, rangeIsMiniTableHeader, isRequired, checksEntry, entityName, rangeToFormat, isEqual, isDependent, rangeDependentToCheckIfBlank, sheetRules) => {
  // Set color
  if (isRequired) {
    var emptyCellBackgroundColor = getCurrentHexFromColorPalette("hibiscus");

  } else {
    var emptyCellBackgroundColor = getCurrentHexFromColorPalette("construction");

  }

  // Set formulae
  if (checksEntry && isEqual) {
    var emptyCellPrimaryRowFormula = '=AND(ISBLANK(' + rangeToCheckIfBlank +
      '), EQ(' + rangeEntityDeterminer + ',' + '"' + entityName + '"' + '),OR(EQ(' + rangeIsMiniTableHeader + ',' + '"TRUE"' + '),ISBLANK(' + rangeIsMiniTableHeader + ')))';

  } else if (checksEntry) {
    var emptyCellPrimaryRowFormula = '=OR(AND(ISBLANK(' + rangeToCheckIfBlank +
      '), NOT(EQ(' + rangeEntityDeterminer + ',' + '"' + entityName + '"' + ')),AND(ISBLANK(' + rangeToCheckIfBlank +
      '),NOT(ISBLANK(' + rangeEntityDeterminer + ')))))'
    /*
    var emptyCellPrimaryRowFormula = '=OR(AND(ISBLANK('+rangeToCheckIfBlank+
    '), NOT(EQ('+rangeEntityDeterminer+','+'"'+entityName+'"'+')),(AND(ISBLANK('+rangeToCheckIfBlank+
    '),NOT(ISBLANK('+rangeEntityDeterminer+')))),OR(EQ('+rangeIsMiniTableHeader+',TRUE),ISBLANK('+rangeIsMiniTableHeader+')))';
    */

  } else {
    var emptyCellPrimaryRowFormula = '=AND(ISBLANK(' + rangeToCheckIfBlank +
      '),OR(EQ(' + rangeIsMiniTableHeader + ',' + '"TRUE"' + '),ISBLANK(' + rangeIsMiniTableHeader + ')))';
  }

  var filledCellPrimaryRowFormula = '=AND(NOT(ISBLANK(' + rangeToCheckIfBlank + ')),OR(EQ(' + rangeIsMiniTableHeader + ',' + '"TRUE"' + '),ISBLANK(' + rangeIsMiniTableHeader + ')))';

  // Create conditional formatting sheetRules

  /**
   * !!!!!!!!!!!!!!!!!!!!!!!!  WARNING!  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   * !!!! ORDER OF SETTING CONDITIONAL FORMATTING IS SIGNIFICANT! !!!!
   * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   */
  var filledCellBackgroundColor = getCurrentHexFromColorPalette("late sun");
  var sheetRules = setSatisfyFormulaConditionalFormatRule(sheet, filledCellPrimaryRowFormula, rangeToFormat, filledCellBackgroundColor, sheetRules); //filledCellPrimaryRowRule

  if (isDependent) {
    var emptyDependentCellPrimaryRowFormula = '=AND(NOT(ISBLANK(' + rangeDependentToCheckIfBlank + ')),EQ(' + rangeEntityDeterminer + ',' + '"' + entityName + '"' + '),OR(EQ(' + rangeIsMiniTableHeader + ',' + '"TRUE"' + '),ISBLANK(' + rangeIsMiniTableHeader + ')))';
    var emptyDependentCellBackgroundColor = getCurrentHexFromColorPalette("hibiscus");

    var sheetRules = setSatisfyFormulaConditionalFormatRule(sheet, emptyDependentCellPrimaryRowFormula, rangeToFormat, emptyDependentCellBackgroundColor, sheetRules);

  }

  var sheetRules = setSatisfyFormulaConditionalFormatRule(sheet, emptyCellPrimaryRowFormula, rangeToFormat, emptyCellBackgroundColor, sheetRules); //emptyCellPrimaryRowRule

  return sheetRules;

}

/**  
 * Apply conditional formatting for rows associated with mini table and are not header rows
 * @param {sheet} sheet - The sheet to be formatted.
 * @param {range} rangeToCheckIfBlank - The range that the formula should check is blank.
 * @param {range} rangeEntityDeterminer - The range that the formula should check for user entry to 
 * dynamically render formatting.
 * @param {range} rangeIsMiniTableHeader - The range that the formula should check to distinguish
 * header vs. non-head rows for mini tables.
 * @param {boolean} isRequired - Specifies if the attribute is required.
 * @param {string} checksEntry - Does formatting formula check user entry to apply format?
 * @param {string} entityName - The entity that the formula should look for in user entries to dynamically render formatting.
 * @param {range} rangeToFormat - The range to be formatted.
 * @param {Array.<*[]>} sheetRules - The conditional formatting rules in the sheet to be formatted.  
 * @return {Array.<*[]>} sheetRules - The updated conditional formatting rules in the sheet to be formatted.
 */

const setConditionalFormattingSecondaryRow = (sheet, rangeToCheckIfBlank, rangeEntityDeterminer, rangeIsMiniTableHeader, isRequired, checksEntry, entityName, rangeToFormat, sheetRules) => {
  // Set Color
  if (isRequired) {
    var emptyCellBackgroundColor = getCurrentHexFromColorPalette("passion fruit");
  } else {
    var emptyCellBackgroundColor = getCurrentHexFromColorPalette("mango");
  }

  // Set formula
  if (checksEntry) {
    var emptyCellSecondaryRowFormula = '=AND(ISBLANK(' + rangeToCheckIfBlank +
      '), EQ(' + rangeEntityDeterminer + ',' + '"' + entityName + '"' + '),EQ(' + rangeIsMiniTableHeader + ',' + '"FALSE"' + '))';

  } else {
    var emptyCellSecondaryRowFormula = '=AND(ISBLANK(' + rangeToCheckIfBlank +
      '),EQ(' + rangeIsMiniTableHeader + ',' + '"FALSE"' + '))';
  }

  var filledCellSecondaryRowFormula = '=AND(NOT(ISBLANK(' + rangeToCheckIfBlank + ')),EQ(' + rangeIsMiniTableHeader + ',' + '"FALSE"' + '))';

  // Create conditional formatting rule
  var filledCellBackgroundColor = getCurrentHexFromColorPalette("early sun");
  var sheetRules = setSatisfyFormulaConditionalFormatRule(sheet, filledCellSecondaryRowFormula, rangeToFormat, filledCellBackgroundColor, sheetRules); // filledCellSecondaryRowRule

  var sheetRules = setSatisfyFormulaConditionalFormatRule(sheet, emptyCellSecondaryRowFormula, rangeToFormat, emptyCellBackgroundColor, sheetRules); // emptyCellSecondaryRowRule

  return sheetRules;


}

/**  
 * Set a conditional formatting rule that is based on a formula and change the background
 * @param {sheet} sheet - The sheet to be formatted.
 * @param {string} forumlaToSatisfy - The formula to be satisifed before changing background of cell.
 * @param {range} rangeToFormat - The range to be formatted.
 * @param {string} backgroundColor - The background color to be applied when the formula is satisfied.
 * @param {Array.<*[]>} sheetRules - The conditional formatting rules in the sheet to be formatted.  
 * @return {Array.<*[]>} sheetRules - The updated conditional formatting rules in the sheet to be formatted.
 */

const setSatisfyFormulaConditionalFormatRule = (sheet, forumlaToSatisfy, rangeToFormat, backgroundColor, sheetRules) => {

  // Can't set range to format outside of this funct

  const rule = SpreadsheetApp.newConditionalFormatRule()
    .whenFormulaSatisfied(forumlaToSatisfy)
    .setBackground(backgroundColor)
    .setRanges([rangeToFormat])
    .build();

  sheetRules.push(rule);

  return sheetRules;

}